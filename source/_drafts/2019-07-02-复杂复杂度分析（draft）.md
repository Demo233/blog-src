---
title: 复杂时间复杂度分析
date: 2019-07-01 11:15:05
categories: 算法与数据结构
mathjax: true
---

较为复杂的分析方法大致可分为四类、分别为：<font color="red">最好时间复杂度、最坏时间复杂度、平均时间复杂度和均摊时间复杂度</font>。

这里有一段代码，针对它下面分别来说一下怎么算着四种时间复杂度。

```java
void add(int element) {
  if (i == len) {
    int new_array[] = new int[len*2];
    for (int j = 0; j < len; ++j) {
      new_array[j] = array[j];
    }
    array = new_array;
    len = 2 * len;
  }
  array[i] = element;
  ++i;
}
```

### 最好、最坏时间复杂度

最好时间复杂度，言明直意，就是在最好情况下求得的时间复杂度，针对长度为N的数组添加一个元素的最好时间复杂度为O（1）

在最好情况下，数组空间很充足，可以直接将数组添加到第i位置

在最坏情况下，数组空间不够，所以要重新申请一个2倍大小的数组空间，把原来array数组中的数据依次copy到new_array，因此最坏的时间复杂度应该是O（N）

### 平均时间复杂度

最好、坏的时间复杂度局限性很大，有时不能准确说明问题，针对这种情况，我们用一个平均值来说明问题。

当i比N小时，时间复杂度为O（1），当i等于N时，时间复杂度为（N），i有N中情况，分别为1～N，每种情况的概率为 1/N，所以有：

$1*(1/n) + 2*(1/n) + ... + (n-2)*(1/n) + (n-1)*(1/n)$

推导最后为（n+1）/2，使用大O表示法，最终平均时间复杂度为O（n/2）

### 均摊时间复杂度

平均时间复杂度好像更具有说服力了，但是其实还不够完美。我们其实发现O（N）的这种情况很少，只有在i为n的时候才触发一次，后面会伴随着多次O（1），这种有规律的交替通常可以用均摊时间复杂度来更加准确的来表示。

在了解这些方法时，不能忘记初衷，我们是为了更好的分析算法的好坏，了解了它们的特点，针对不同的情况选用不同的分析方法。
