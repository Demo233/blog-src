---
title: 线程等待与唤醒
date: 2020-12-03 22:33:08
categories: 后端
tags: Java
---

今天我们讨论一下多线程的知识，等待（wait）与唤醒（notify）。这个东西有什么用？能用到哪？你一定有印象，还记得在操作系统课程上时的讲的生产者和消费者模型吗？信号量同步的过程，这两个操作贯穿其中，有兴趣的可以看一下实现的过程。

### wait(), notify(), notifyAll()介绍

在Java语言中的Object对象里，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。

Object类中关于等待/唤醒的API详细信息如下：

* notify() - 唤醒在此对象监视器上等待的单个线程。
* notifyAll() - 唤醒在此对象监视器上等待的所有线程。
* wait() - 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。
* wait(long timeout) - 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
* wait(long timeout, int nanos)	- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。

### wait()和notify()示例

下面通过示例演示"wait()和notify()配合使用的情形"。

```java
class ThreadA extends Thread{

    public ThreadA(String name) {
        super(name);
    }

    public void run() {
        synchronized (this) {
            System.out.println(Thread.currentThread().getName()+" call notify()");
            // 唤醒当前的wait线程
            notify();
        }
    }
}

public class WaitTest {

    public static void main(String[] args) {

        ThreadA t1 = new ThreadA("t1");

        synchronized(t1) {
            try {
                // 启动“线程t1”
                System.out.println(Thread.currentThread().getName()+" start t1");
                t1.start();

                // 主线程等待t1通过notify()唤醒。
                System.out.println(Thread.currentThread().getName()+" wait()");
                t1.wait();

                System.out.println(Thread.currentThread().getName()+" continue");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```
