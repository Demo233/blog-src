---
title: ThreadLocal
date: 2020-12-07 21:00:16
categories: 后端
tags: Java
---

ThreadLocal类是java.lang包中提供的类，下面我们从它的原理、主要方法和应用场景来讨论一下。

### 介绍

> This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).

大致的含义是:

> 该类提供线程本地变量，这些变量与普通变量不同，每个线程访问一个（通过其get或set方法）设置其自己的ThreadLocal，独立初始化的变量副本。

在了解ThreadLocal之前，我们先了解一下Thread、ThreadLocalMap和ThreadLocal这三者的关系。如下图所示：
![title](https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/12/07/1607347464265-1607347464295.png)

**1. 每个Thread中都维护了一个ThreadLocalMap**

```java
// 查看Thread.class

/* ThreadLocal values pertaining to this thread. This map is maintained
* by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
```

**2. 每个ThreadLocalMap中都维护了多个ThreadLocal**

```java
// 查看ThreadLocalMap.class

/**
* The entries in this hash map extend WeakReference, using
* its main ref field as the key (which is always a
* ThreadLocal object).  Note that null keys (i.e. entry.get()
* == null) mean that the key is no longer referenced, so the
* entry can be expunged from table.  Such entries are referred to
* as "stale entries" in the code that follows.
*/
static class Entry extends WeakReference<ThreadLocal<?>> {
   /** The value associated with this ThreadLocal. */
   Object value;

   Entry(ThreadLocal<?> k, Object v) {
      super(k);
      value = v;
   }
}

```


### 应用场景

该类提供了线程本地本地变量，

```java
/**
 * 描述：     1000个打印日期的任务，用线程池来执行
 * @author zyh 
 * @date 2020-12-07 21:45:36
 */
public class ThreadLocalDemo1 {

    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);

    public static Set<String> result = new HashSet<>();

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalDemo1().date(finalI);
                    System.out.println("second: " + finalI + "\tdate: " + date);
                    result.add(date);
                }
            });
        }
        Thread.sleep(1000 * 5L);
        threadPool.shutdown();
        System.out.println(result.size() == 10000? "无线程安全": "出现线程安全");
    }

    public String date(int seconds) {
        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return dateFormat.format(date);
    }
}
```
如果没有成功可以稍微加大线程数，多试几次。

![title](https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/12/07/1607348677035-1607348677036.png)

**ThreadLocal解决问题**

思路就是为每个Thread分配实例，而不是多个线程公用同一个DateFormat实例，如下面代码所示:

```java

```


在开始前，不妨先想一个问题，有没有办法在不加锁的情况下实现同步操作？这篇文章将带你解开答案。

主要方法

T initialValue();
void set(T t);
T get();
void remove();