---
title: ThreadLocal
date: 2020-12-07 21:00:16
categories: 后端
tags: Java
---

ThreadLocal类是java.lang包中提供的类，下面我们从它的原理、主要方法和应用场景来讨论一下。

### 介绍

> This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).

大致的含义是: 

> ThreadLocal是保存线程的本地变量，访问的get/set方法都是相对独立的，``private static ThreadLocal`` 实例化出来的私有静态字段是希望将某个状态与线程做关联。

大白话就是，ThreadLocal是和线程相关的，在一个线程的生命周期内，任意的set/get的值都只和当前线程相关。


### 原理

在了解ThreadLocal之前，我们先了解一下Thread、ThreadLocalMap和ThreadLocal这三者的关系。如下图所示：
![title](https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/12/07/1607347464265-1607347464295.png)

**1. 每个Thread中都维护了一个ThreadLocalMap**

```java
// 查看Thread.class

/* ThreadLocal values pertaining to this thread. This map is maintained
* by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
```

**2. 每个ThreadLocalMap中都维护了多个ThreadLocal**

```java
// 查看ThreadLocalMap.class

/**
* The entries in this hash map extend WeakReference, using
* its main ref field as the key (which is always a
* ThreadLocal object).  Note that null keys (i.e. entry.get()
* == null) mean that the key is no longer referenced, so the
* entry can be expunged from table.  Such entries are referred to
* as "stale entries" in the code that follows.
*/
static class Entry extends WeakReference<ThreadLocal<?>> {
   /** The value associated with this ThreadLocal. */
   Object value;

   Entry(ThreadLocal<?> k, Object v) {
      super(k);
      value = v;
   }
}

```


### 同步

网上有一些说可以解决多线程问题，这里举一个使用ThreadLocal出现同步的栗子。比如下面这样:

```java
/**
 * @author zyh
 * @Description:
 */
public class ThreadId {

    // 线程Id 共享变量
    private static Integer id = new Integer(0);

    // 获取线程ID
    private static final ThreadLocal<Integer> threadId = new ThreadLocal<Integer>(){
        @Override
        protected Integer initialValue() {
            return id ++;
        }
    };

    public static int get(){
        return threadId.get();
    }

    public static void main(String[] args) {

        for (int i = 0; i < 20; i++) {
            new Thread(()->{
                System.out.println(ThreadId.get());
            }).start();

        }
    }

}

```
![title](https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/12/12/1607768722697-1607768722727.png)

**对于静态变量id，因为在内存只实例化了一次，因为多个线程内是相同的引用**，所以这里获取的值会出现线程安全问题。那怎么解决？解决办法就是让这个静态变量id保持原子性，再或者让它实例化多次，像下面这样修改程序：

```java
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author zyh
 * @Description: 
 */
public class ThreadId {

    // 线程Id 共享变量
    private static AtomicInteger id = new AtomicInteger(0);

    // 获取线程ID
    private static final ThreadLocal<Integer> threadId = new ThreadLocal<Integer>(){
        @Override
        protected Integer initialValue() {
            return id.getAndIncrement();
        }
    };

    public static int get(){
        return threadId.get();
    }

    public static void main(String[] args) {


        for (int i = 0; i < 20; i++) {
            new Thread(()->{
                System.out.println(ThreadId.get());
            }).start();

        }

    }

}
```

这里``AtomicInteger``是``JUC``包中的类，能够保证id的原子性加一操作。因此不会解决了同步问题。

### InheritableThreadLocal

在开发中不免遇到**子线程获取父线程的ThreadLocal中的值**的场景。只使用ThreadLocal满足不了需求，举个例子：

```java

```

```java
/**
 * 描述：     1000个打印日期的任务，用线程池来执行
 * @author zyh 
 * @date 2020-12-07 21:45:36
 */
public class ThreadLocalDemo1 {

    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);

    public static Set<String> result = new HashSet<>();

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10000; i++) {
            int finalI = i;
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    String date = new ThreadLocalDemo1().date(finalI);
                    System.out.println("second: " + finalI + "\tdate: " + date);
                    result.add(date);
                }
            });
        }
        Thread.sleep(1000 * 5L);
        threadPool.shutdown();
        System.out.println(result.size() == 10000? "无线程安全": "出现线程安全");
    }

    public String date(int seconds) {
        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return dateFormat.format(date);
    }
}
```
如果没有成功可以稍微加大线程数，多试几次。

![title](https://raw.githubusercontent.com/Demo233/images/main/gitnote/2020/12/07/1607348677035-1607348677036.png)

**ThreadLocal解决问题**

思路就是为每个Thread分配实例，而不是多个线程公用同一个DateFormat实例，如下面代码所示:

```java

```


在开始前，不妨先想一个问题，有没有办法在不加锁的情况下实现同步操作？这篇文章将带你解开答案。

主要方法

T initialValue();
void set(T t);
T get();
void remove();