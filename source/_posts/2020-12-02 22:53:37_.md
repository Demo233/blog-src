---
title: LRU
date: 2020-12-02 22:53:37
categories: 算法与数据结构
tags: 链表
---

### 简单介绍

还记得第一次听到些词是在计算机组成原理课上，讲高速缓存存储器-cache章节涉及到的，当时一脸懵逼不知道说的是啥。

* LRU - 最近最少使用策略(Lastest Recently Used)
* LFU - 最少使用策略(Lastest Frequently Used)
* FIFO - 先进先出(First In First Out)

大家都是比较实在的人，我当时就不想背这些东西，我相信你肯定也不喜欢硬背这些东西，其实他们离我们生活很近，只是我们忽略了没有在意它们。

你可以试想一下如果现在有一大堆书，你会以什么方式扔这些书，对应⼀下，你的选择标准是不是和上⾯的三种策略神似呢？

### 链表实现LRU

下面用链表实现以下LRU策略。

要求是：链表做存储，当链表满了，我们就按照LRU最近最少使用策略的丢数据。

#### 1.链表数据结构

```java
public class LRULinkedList<T> {

    // 记录当前容量
    private int CAPACITY = 0;

    // 默认容量
    private int DEFAULT_CAPACITY = 5;

    // 设置守卫简化代码
    private SNode head;

    // 链表节点
    class SNode<T> {
        // 数据
        T data;
        // 指向下一个节点的指针
        SNode next;
    }
}
```

**守卫**

守卫的意思是守护边界，用于管理边界的一些操作，因为边界操作往往会出现很多种情况十分复杂，利用守卫就可以屏蔽掉多种情况，这是编码的一种技巧。

下面用两组场景，说一下写它的原因让我们写起来不是那么的得心应手，因为每个操作都要考虑边界值。

**第一组**

比如往链表结点p后⾯插⼊⼀个新的结点，正常插入只需要这样写。

```java
newNode->next = p->next; 
p->next = newNode;
```

但是，当我们要向⼀个空链表中插⼊第⼀个结点,因此考虑链表是否未空的情况，代码就要在多写下面内容。

```java
if(head == null){
    head = newNode;
}
```
**第二组**

再比如删除链表中的节点，如果要删除p节点的后继节点，只需要这样写

```java
p->next = p->next->next;
```

但是如果要删除最后一个节点，就要多写下面的内容。

```java
if (head->next == null) { 
    head = null; 
}
```

那问题来了，有没有办法省掉第一组和第二组的 判断代码呢？现在不复杂还好判断，遇到复杂的我们就很容易漏掉，产生bug，这时候守卫就派上用场了。

如果感觉有点不太理解，可以尝试着写写，debug一下看看。